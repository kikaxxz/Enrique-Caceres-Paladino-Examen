# -*- coding: utf-8 -*-
"""Examen

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11fYPr50h54jMUnSP0LteerVeKP_Sox7f

# **Configuración e Importaciones**
"""

import os
import datetime

# --- Constantes del Archivo ---
FILENAME = 'equipos_planta.dat'

# --- Definición de la Longitud Fija de los Registros ---
# ID: 5 caracteres
# Nombre: 30 caracteres
# Tipo: 20 caracteres
# Calibración: 10 caracteres (float como string)
# Fecha Mantenimiento: 10 caracteres (YYYY-MM-DD)
# Newline (\n): 1 caracter
# --------------------------------------------------
# TOTAL: 76 bytes por registro

ID_LEN = 5
NOMBRE_LEN = 30
TIPO_LEN = 20
CAL_LEN = 10
FECHA_LEN = 10
# El +1 es por el carácter de nueva línea '\n'
RECORD_LEN = ID_LEN + NOMBRE_LEN + TIPO_LEN + CAL_LEN + FECHA_LEN + 1

# --- Índice Global para Acceso Indexado ---
# Este diccionario almacenará: {'TipoDeEquipo': [lista_de_offsets_en_bytes]}
global_indice_tipo = {}

"""# **2. Funciones Auxiliares (Parsing y Formateo)**"""

def _parse_line(line):
  """
  Toma una línea de 76 bytes del archivo y la convierte en un diccionario.
  """
  if len(line) < RECORD_LEN - 1: # Asegurarse de que la línea no esté incompleta
      return None

  try:
    equipo = {
        'id': line[0:ID_LEN].strip(),
        'nombre': line[ID_LEN : ID_LEN + NOMBRE_LEN].strip(),
        'tipo': line[ID_LEN + NOMBRE_LEN : ID_LEN + NOMBRE_LEN + TIPO_LEN].strip(),
        'calibracion': float(line[ID_LEN + NOMBRE_LEN + TIPO_LEN : ID_LEN + NOMBRE_LEN + TIPO_LEN + CAL_LEN].strip()),
        'fecha': line[ID_LEN + NOMBRE_LEN + TIPO_LEN + CAL_LEN : ID_LEN + NOMBRE_LEN + TIPO_LEN + CAL_LEN + FECHA_LEN].strip()
    }
    return equipo
  except ValueError:
    print(f"[Error de parseo] Línea corrupta: {line}")
    return None


def _print_equipo(equipo_dict):
  """
  Imprime un diccionario de equipo de forma legible.
  """
  if equipo_dict:
    print(f"  > ID: {equipo_dict['id']} | Nombre: {equipo_dict['nombre']} | Tipo: {equipo_dict['tipo']} | Calibración: {equipo_dict['calibracion']} | Últ. Manto: {equipo_dict['fecha']}")

"""# **3. Crear Archivo y Añadir Equipos**"""

def crear_o_agregar_equipo():
  """
  Pide datos al usuario y los guarda en el archivo con formato de longitud fija.
  """
  print("\n--- Añadir Nuevo Equipo ---")
  try:
    # 1. Obtener datos del usuario
    id_str = input("Ingrese ID (número entero, ej. 1, 2, 3...): ")
    if not id_str.isdigit():
        print("Error: El ID debe ser un número entero.")
        return

    nombre = input("Ingrese Nombre del equipo: ")
    tipo = input("Ingrese Tipo (Ej. Sensor, Actuador, PLC): ")
    valor_cal_str = input("Ingrese Valor de Calibración (ej. 123.45): ")
    float(valor_cal_str) # Validar que es un float

    fecha_manto = input("Ingrese Fecha de Último Mantenimiento (YYYY-MM-DD): ")
    # Validar formato de fecha
    datetime.datetime.strptime(fecha_manto, '%Y-%m-%d')

    # 2. Formatear a longitud fija (rellenando con espacios)
    # .ljust(N) justifica a la izquierda y rellena con espacios hasta N caracteres
    record_id = id_str.ljust(ID_LEN)
    record_nombre = nombre.ljust(NOMBRE_LEN)
    record_tipo = tipo.ljust(TIPO_LEN)
    record_cal = valor_cal_str.ljust(CAL_LEN)
    record_fecha = fecha_manto.ljust(FECHA_LEN)

    # 3. Construir el registro final (75 chars + '\n')
    record_line = f"{record_id}{record_nombre}{record_tipo}{record_cal}{record_fecha}\n"

    # 4. Validar longitud (Sanity Check)
    if len(record_line) != RECORD_LEN:
      print(f"Error: La longitud del registro es incorrecta ({len(record_line)}). No se guardó.")
      return

    # 5. Escribir en el archivo (modo 'a' para append)
    with open(FILENAME, 'a') as f:
      f.write(record_line)

    print(f"¡Equipo '{nombre}' (ID: {id_str}) guardado exitosamente!")
    # Actualizar el índice después de añadir
    construir_indice_tipo()

  except ValueError as e:
    print(f"Error en la entrada de datos: {e}. El equipo no fue guardado.")
  except Exception as e:
    print(f"Ocurrió un error inesperado: {e}")

def listar_por_mantenimiento():
  """
  Muestra equipos que necesitan mantenimiento en un rango de fechas.
  """
  print("\n--- Listar por Fecha de Mantenimiento ---")
  try:
    fecha_inicio_str = input("Ingrese Fecha de INICIO (YYYY-MM-DD): ")
    fecha_fin_str = input("Ingrese Fecha de FIN (YYYY-MM-DD): ")

    fecha_inicio = datetime.datetime.strptime(fecha_inicio_str, '%Y-%m-%d').date()
    fecha_fin = datetime.datetime.strptime(fecha_fin_str, '%Y-%m-%d').date()

    print(f"\nEquipos con mantenimiento entre {fecha_inicio_str} y {fecha_fin_str}:")
    encontrados = 0

    if not os.path.exists(FILENAME):
      print(f"El archivo {FILENAME} aún no existe.")
      return

    with open(FILENAME, 'r') as f:
      for line in f:
        equipo = _parse_line(line)
        if equipo:
          try:
            fecha_equipo = datetime.datetime.strptime(equipo['fecha'], '%Y-%m-%d').date()
            if fecha_inicio <= fecha_equipo <= fecha_fin:
              _print_equipo(equipo)
              encontrados += 1
          except ValueError:
            # Ignorar si la fecha en el archivo está mal formateada
            pass

    if encontrados == 0:
      print("No se encontraron equipos en ese rango de fechas.")

  except ValueError:
    print("Error: Formato de fecha incorrecto. Use YYYY-MM-DD.")

"""# **4. Lectura Secuencial**"""

def lectura_secuencial():
  """
  Lee el archivo completo secuencialmente y muestra todos los registros.
  """
  print("\n--- Lectura Secuencial de Todos los Equipos ---")
  if not os.path.exists(FILENAME):
    print(f"El archivo {FILENAME} no existe. Añada un equipo primero.")
    return

  with open(FILENAME, 'r') as f:
    lineas_totales = 0
    for line in f:
      if len(line) == RECORD_LEN:
        equipo = _parse_line(line)
        _print_equipo(equipo)
        lineas_totales += 1
      elif len(line.strip()) > 0:
        print(f"[Advertencia] Línea ignorada (longitud incorrecta): {len(line)} bytes")


    if lineas_totales == 0:
      print("El archivo está vacío.")
    else:
      print(f"\n--- Fin del archivo. Total de {lineas_totales} equipos listados. ---")

"""# **5. Busqueda por acceso directo.**"""

def busqueda_directa_por_id():
  """
  Busca un equipo por ID usando acceso directo con seek().
  Asume que ID=1 es el registro 0, ID=2 es el registro 1, etc.
  """
  print("\n--- Búsqueda por Acceso Directo (por ID) ---")
  if not os.path.exists(FILENAME):
    print(f"El archivo {FILENAME} no existe.")
    return

  try:
    id_buscar = input("Ingrese el ID del equipo a buscar: ")
    id_num = int(id_buscar)

    if id_num <= 0:
      print("El ID debe ser un número positivo.")
      return

    # --- Cálculo del Acceso Directo ---
    # (ID - 1) nos da el índice del registro (ej. ID 1 -> registro 0)

    offset = (id_num - 1) * RECORD_LEN

    with open(FILENAME, 'r') as f:
      # Mover el "puntero" del archivo al byte calculado
      f.seek(offset)

      # Leer solo la línea en esa posición
      line = f.readline()

      if line and len(line) == RECORD_LEN:
        equipo = _parse_line(line)
        # Verificación final: ¿El ID en el registro coincide con el buscado?
        if equipo and equipo['id'] == id_buscar:
          print("Equipo encontrado:")
          _print_equipo(equipo)
        else:
          print(f"Error: El ID {id_buscar} no se encontró en la posición calculada.")
          print("Esto puede pasar si los IDs no son secuenciales o si un ID fue eliminado.")
      else:
        print(f"No se encontró ningún equipo con el ID {id_buscar}.")

  except ValueError:
    print("Error: El ID debe ser un número entero.")
  except Exception as e:
    print(f"Ocurrió un error durante la búsqueda: {e}")

"""# **6. Acceso Indexado**"""

def construir_indice_tipo():
  """
  Lee el archivo completo UNA VEZ y construye el índice de tipos.
  El índice mapea 'Tipo' -> [lista de offsets en bytes].
  """
  global global_indice_tipo
  global_indice_tipo.clear() # Limpiar el índice anterior

  if not os.path.exists(FILENAME):
    return # No hay archivo, no hay índice

  # print("[Info] Construyendo índice de tipos...")
  with open(FILENAME, 'r') as f:
    while True:
      # 1. Guardar la posición actual (offset) ANTES de leer
      current_offset = f.tell()

      # 2. Leer la línea
      line = f.readline()

      # 3. Si no hay más líneas, parar
      if not line:
        break

      # 4. Procesar la línea si es válida
      if len(line) == RECORD_LEN:
        # Extraer solo el tipo (es más rápido que _parse_line)
        tipo = line[ID_LEN + NOMBRE_LEN : ID_LEN + NOMBRE_LEN + TIPO_LEN].strip()

        if tipo:
          if tipo not in global_indice_tipo:
            global_indice_tipo[tipo] = []
          # 5. Añadir el offset a la lista de ese tipo
          global_indice_tipo[tipo].append(current_offset)

  # print(f"Índice construido: {global_indice_tipo}")
  print("\n[Sistema] Índice de tipos de equipo actualizado.")


def busqueda_indexada_por_tipo():
  """
  Busca todos los equipos de un tipo específico usando el índice.
  """
  print("\n--- Búsqueda Indexada (por Tipo) ---")
  if not global_indice_tipo:
    print("El índice está vacío. El archivo no existe o está vacío.")
    return

  print(f"Tipos disponibles en el índice: {list(global_indice_tipo.keys())}")
  tipo_buscar = input("Ingrese el Tipo de equipo a buscar: ")

  if tipo_buscar in global_indice_tipo:
    offsets = global_indice_tipo[tipo_buscar]
    print(f"\nEquipos encontrados para el tipo '{tipo_buscar}' (Total: {len(offsets)}):")

    with open(FILENAME, 'r') as f:
      for offset in offsets:
        # Usamos seek() para saltar a cada posición guardada en el índice
        f.seek(offset)
        line = f.readline()
        equipo = _parse_line(line)
        _print_equipo(equipo)
  else:
    print(f"No se encontraron equipos del tipo '{tipo_buscar}' en el índice.")

"""# **7. Menú Principal**"""

def menu_principal():
  """
  Muestra el menú principal y maneja la lógica de la aplicación.
  """
  # Construir el índice al iniciar la aplicación
  construir_indice_tipo()

  while True:
    print("\n========= MENÚ DE GESTIÓN DE EQUIPOS =========")
    print("1. Añadir nuevo equipo")
    print("2. Listar TODOS los equipos (Lectura Secuencial)")
    print("3. Buscar equipo por ID (Acceso Directo)")
    print("4. Buscar equipos por Tipo (Acceso Indexado)")
    print("5. Listar equipos por rango de fecha de mantenimiento")
    print("6. Salir")
    print("==============================================")

    opcion = input("Seleccione una opción: ")

    if opcion == '1':
      crear_o_agregar_equipo()
    elif opcion == '2':
      lectura_secuencial()
    elif opcion == '3':
      busqueda_directa_por_id()
    elif opcion == '4':
      busqueda_indexada_por_tipo()
    elif opcion == '5':
      listar_por_mantenimiento()
    elif opcion == '6':
      print("Saliendo del programa.")
      break
    else:
      print("Opción no válida. Intente de nuevo.")


menu_principal()